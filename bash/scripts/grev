#!/bin/sh -u

BASE_DIR=$(cd $(dirname "$0") && pwd -P)
SCRIPT_NAME=$(basename "$0")

fail() {
	echo "$@"
	exit 1
}

usage() {
        cat <<EOI
usage: $SCRIPT_NAME [ARGS] TICKET_NUM [BRANCH_INDEX]

Checks out a git branch based on a "\$initials/\$ticket/\$description" branch naming convention. If multiple branches are found, an index number must be provided.

ARGS:
  -f, --fetch     run "git fetch" first; else one runs in the background
  -d, --delete    delete existing branch first, discarding local commits
  -h, --help      print this information and exit
EOI
        return 1
    }
[ $# -eq 0 ] && {
    usage
    exit 1
}

fetch=0
delete=0
ticket=
branch_index=

while [ $# -gt 0 ]; do
    arg="$1"
    shift
    case "$arg" in 
        --fetch|-f)
            fetch=1
            ;;
        --delete|-d)
            delete=1
            ;;
        --help|-h)
            usage
            exit 0
            ;;
        --fd|-df)
            fetch=1
            delete=1
            exit
            ;;
        *)
            if [ -z "$ticket" ]; then
                ticket="$arg"
            elif [ -z "$branch_index" ]; then
                branch_index="$arg"
                [ $branch_index -ge 1 -a $branch_index -le 100 ] \
                    || fail "Invalid branch index: a value between 1-100 expected"
            else
                fail "Ticket $ticket already specified"
            fi
            ;;
    esac
done

# sanity checks!
[ -n "$ticket" ] || {
    usage
    fail "No ticket specified"
}
( echo "$ticket" | grep -qe '^[0-9]\+$' ) || {
    usage
    fail "Invalid ticket: $ticket"
}
# we're in a git repo, right?
cur_branch=$(git rev-parse --abbrev-ref HEAD) \
    || fail "No git repo found?"

# make sure we find the branch requested -- and only one
branches=$(git branch -a | grep "remotes/origin/[^/]\+/$ticket/")\
    || fail "Failed to locate a branch for ticket $ticket"
[ $(echo "$branches" | wc -l) -eq 1 ] || {
    # we better have an index to confirm that we know we want a specific branch
    [ -z "$branch_index" ] && {
        expanded=
        ctr=0
        for branch in $branches; do
            let ctr++
            expanded="$expanded\n  $ctr. $branch"
        done
        fail "Multiple remote branches found; branch index required:\n$expanded"
    }
    # pick out the specific branch
    branches=$(echo "$branches" | sed "${branch_index}q;d")
}
# and parse out the branch name
branch=${branches##*origin/}

# make things easy on ourself and pivot to master
# otherwise you can't delete a branch you're in to pull updates easier
# it also helps avoid abandoning local changes
[ "$cur_branch" == "master" ] \
    || git checkout master >/dev/null \
    || fail "Failed to center onto 'master' branch"

# fetch/delete first, as requested
[ $fetch -eq 1 ] && git fetch origin $branch
[ $delete -eq 1 ] && git branch -D "$branch"
git checkout "$branch" || fail "Failed to change git branch"

# if we didn't fetch up front, do a quiet background fetch now
[ $fetch -eq 0 ] && {
    git fetch origin $branch &>/dev/null &
    disown -r
}
